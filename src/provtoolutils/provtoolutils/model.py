import datetime
import io
import json
import logging
import os
import prov.model as prov  # type: ignore
import uuid

from prov.serializers.provjson import ProvJSONSerializer

from enum import Enum
from provtoolutils.constants import model_encoding
from provtoolutils.utilities import calculate_data_hash

from typing import Any, Dict, List, Union

FORMAT = '%(asctime)-15s %(levelname)s %(message)s'
logging.basicConfig(format=FORMAT)
logger = logging.getLogger('provtool')
logger.setLevel('WARNING')
if 'PROVTOOLLOGLEVEL' in os.environ:
    allowed_log_level = ['CRITICAL', 'ERROR', 'WARNING', 'INFO', 'DEBUG']
    if os.environ['PROVTOOLLOGLEVEL'] in allowed_log_level:
        logger.setLevel(os.environ['PROVTOOLLOGLEVEL'])
    else:
        logger.warn('Log level is set to incorrect value: {}. Only one of {} is allowed.',
                    os.environ['PROVTOOLLOGLEVEL'], ', '.join(allowed_log_level)
                    )


class Entity(Enum):
    FILE = 1


class ProvIdentifiableObject:
    """
    The base class for all instances of the used data model.
    """
    def __init__(self, generate_uuid=False):
        """
        There are cases, where this would lead to a problem. Assume for example a long (infinitely) running activity
        where no end date is known so far. This activity needs to be referenced nevertheless. Therefore, the id can
        be generated by using a uuid if **generate_uuid** is set to **True**.

        :param generate_uuid: By default, the id is calculated by taking the hash over all attributes of the instance.
        """
        if generate_uuid:
            self._internal_id = uuid.uuid4().hex + uuid.uuid4().hex
        else:
            self._internal_id = None

    @property
    def id(self):
        if self._internal_id is not None:
            return self._internal_id
        else:
            sorted_attributes = sorted(vars(self).keys())
            result = ''
            for attr in sorted_attributes:
                attr_value = getattr(self, attr)
                if attr_value:
                    if isinstance(attr_value, ProvIdentifiableObject):
                        result = result + attr_value.id
                    elif isinstance(attr_value, datetime.datetime):
                        result = result + datetime.datetime.strftime(attr_value, '%Y-%m-%dT%H:%M:%S')
                    # Explicitly catch expected types to avoid errors later on
                    elif isinstance(attr_value, (int, bool, str, list, dict)):
                        av = attr_value
                        if isinstance(attr_value, list):
                            av = attr_value.sort()
                        result = result + json.dumps(av, ensure_ascii=False, sort_keys=True)
                    else:
                        raise ValueError('Unknown type in id calculation: {}'.format(type(attr_value)))
            logger.debug('Using the following information for hash calculation with encoding %s: %s',
                         model_encoding,
                         result
                         )
            return calculate_data_hash(result.encode(model_encoding))


def make_provstring(entityname: str, entitytype: Entity,
                    author: Union['Machine', 'Person', 'ActingSoftware'], activity: 'Activity',
                    datahash: str) -> bytes:
    above = author
    while above.acted_on_behalf_of is not None:
        above = above.acted_on_behalf_of
        if type(above) == Person or type(above) == Organization:
            break

    if type(above) == ActingSoftware:
        raise ValueError('No pure software agents are allowed as authors')

    document = prov.ProvDocument()

    document.set_default_namespace('http://dlr.de/provtool')
    document.add_namespace('provtool', 'http://dlr.de/provtool')
    document.add_namespace('person', 'http://schema.org/Person')
    document.add_namespace('creative', 'http://schema.org/CreativeWork')
    document.add_namespace('software', 'http://schema.org/SoftwareApplication')

    prov_types = {
        Entity.FILE: 'File'
    }
    # Use a lookup in the dictionary without get to provoke error in case on not defined type.
    prov_entity_properties = [
        ('prov:label', entityname)
    ]
    if entitytype is not None:
        prov_entity_properties.append((prov.PROV_TYPE, prov_types[entitytype]))
    if entitytype is not None:
        prov_entity_properties.append(('provtool:datahash', datahash))

    document.entity('self', tuple(prov_entity_properties))

    prov_activity = document.activity(activity.id, activity.start_time, activity.end_time,
                                      activity.to_prov_attr())
    if activity.started_by is not None:
        document.wasStartedBy(prov_activity, None, activity.started_by.id)

    ag = author
    pag = document.agent(ag.id, ag.to_prov_attr())

    while ag is not None:
        ag = ag.acted_on_behalf_of
        if ag is not None:
            pag2 = document.agent(ag.id, ag.to_prov_attr())
            document.actedOnBehalfOf(pag, pag2)
            pag = pag2

    for used in activity.used:
        document.usage(prov_activity, used)

    stream = io.StringIO()
    ProvJSONSerializer(document).serialize(stream)
    provdata = json.dumps(json.loads(''.join(stream.getvalue())), ensure_ascii=False, sort_keys=True)

    return provdata.encode(model_encoding)


class Organization(ProvIdentifiableObject):
    def __init__(self, name: str, acted_on_behalf_of: Union['Person', 'Organization'] = None):
        ProvIdentifiableObject.__init__(self)
        self.name = name
        self.acted_on_behalf_of = acted_on_behalf_of

    def to_prov_attr(self):
        return {
            'prov:type': 'prov:Organization',
            'prov:label': self.name
        }


class Person(ProvIdentifiableObject):
    def __init__(self, given_name="", family_name="", acted_on_behalf_of: Union['Person', 'Organization'] = None):
        ProvIdentifiableObject.__init__(self)
        self.given_name = given_name
        self.family_name = family_name
        self.acted_on_behalf_of = acted_on_behalf_of

    def to_prov_attr(self):
        return self.to_json()

    def to_json(self):
        return {
            'prov:type': 'prov:Person',
            'person:givenName': self.given_name,
            'person:familyName': self.family_name,
            'prov:label': self.given_name + ' ' + self.family_name
        }


class Machine(ProvIdentifiableObject):
    def __init__(self, label='', acted_on_behalf_of: Union['Person', 'Organization'] = None):
        ProvIdentifiableObject.__init__(self)
        self.label = label
        self.acted_on_behalf_of = acted_on_behalf_of

    def to_prov_attr(self):
        return self.to_json()

    def to_json(self):
        return {
            'prov:type': 'provtool:Machine',
            'prov:label': self.label
        }


class Software(ProvIdentifiableObject):

    def __init__(self, creator: str, version: str, url: str, label: str):
        ProvIdentifiableObject.__init__(self)
        self.creator = creator
        self.version = version
        self.location = url
        self.requirements: List['Software'] = []

        self.label = label

    def to_prov_attr(self):
        return {
            'prov:type': 'prov:SoftwareAgent',
            'creative:creator': self.creator,
            'software:softwareVersion': self.version,
            'prov:location': self.location,
            'prov:label': self.label
        }


class ActingSoftware(Software):
    acted_on_behalf_of = None

    def __init__(self, acted_on_behalf_of: Union['Person', 'ActingSoftware'], creator, version, label,
                 location):
        if acted_on_behalf_of is None:
            raise ValueError('No pure software agents are allowed as authors')

        Software.__init__(self, creator, version, location, label)
        self.acted_on_behalf_of = acted_on_behalf_of


class Activity(ProvIdentifiableObject):
    def __init__(self, start_time: datetime, end_time: datetime, location: str, label: str,
                 means: str, used: List[str] = None, started_by: 'Activity' = None,
                 generate_uuid=True, additional_props: Dict[str, Any] = dict()):
        """
        :param start_time:
        :param end_time:
        :param location:
        :param label:
        :param means:
        :param used:
        :param started_by:
        :param generate_uuid: Use a uuid which is not based on the activity attributes (start_time, label, ...).
        Defaults to True because in most cases the end time of an activity is not known when the activity id is already
        needed for reference. Set it to False with caution.
        """
        ProvIdentifiableObject.__init__(self, generate_uuid=generate_uuid)
        if start_time is not None and (start_time.utcoffset() is None or start_time.utcoffset().total_seconds() != 0):
            raise ValueError("Start time not given in UTC: {}".format(start_time))
        if end_time is not None and (end_time.utcoffset() is None or end_time.utcoffset().total_seconds() != 0):
            raise ValueError("End time not given in UTC: {}".format(end_time))
        self.start_time = None
        # Set the precision for the datetime. Although there are better options then strftime &
        # strptime, this solution ensures, that a format string can be used in all places. Makes
        # refactoring much easier and should be kept until it becomes a performance bottle neck.
        if start_time is not None:
            self.start_time = datetime.datetime.strptime(datetime.datetime.strftime(start_time,
                                                                                    '%Y-%m-%dT%H:%M:%S%z'
                                                                                    ), '%Y-%m-%dT%H:%M:%S%z')
        self.end_time = None
        # Set the precision for the datetime. Although there are better options then strftime &
        # strptime, this solution ensures, that a format string can be used in all places. Makes
        # refactoring much easier and should be kept until it becomes a performance bottle neck.
        if end_time is not None:
            self.end_time = datetime.datetime.strptime(datetime.datetime.strftime(end_time,
                                                                                  '%Y-%m-%dT%H:%M:%S%z'
                                                                                  ), '%Y-%m-%dT%H:%M:%S%z')
        self.location = location
        self.label = label
        self.means = means
        self.used = [] if used is None else used
        self.started_by = started_by
        self.additional_props = additional_props

    def to_prov_attr(self):
        """
        Provides the attributes which are not explicitely needed by the W3C prov data model.
        """
        result = {k: v for (k, v) in self.additional_props.items()}
        result['prov:location'] = self.location
        result['provtool:means'] = self.means
        result['prov:label'] = self.label

        return result

    def to_json(self):
        tuples = []
        tuples.append(("id", self.id))
        tuples.append(("start_time", datetime.datetime.strftime(self.start_time, "%Y-%m-%dT%H:%M:%S%z")))
        if self.end_time is not None:
            tuples.append(("end_time", datetime.datetime.strftime(self.end_time, "%Y-%m-%dT%H:%M:%S%z")))
        tuples.append(("location", self.location))
        tuples.append(("label", self.label))
        tuples.append(("means", self.means))
        tuples.append(("used", self.used))
        if self.started_by is not None:
            tuples.append(("started_by", self.started_by.to_json()))

        d = {t[0]: t[1] for t in tuples}
        return json.dumps(d, ensure_ascii=False, sort_keys=True)

    @staticmethod
    def from_json(json_string):
        result = Activity(None, None, None, None, None)
        js = json.loads(json_string)
        js['_internal_id'] = js['id']
        del js['id']
        for k, v in js.items():
            setattr(result, k, v)
        if result.start_time is not None:
            result.start_time = datetime.datetime.strptime(result.start_time, '%Y-%m-%dT%H:%M:%S%z')
        if result.end_time is not None:
            result.end_time = datetime.datetime.strptime(result.end_time, '%Y-%m-%dT%H:%M:%S%z')
        return result
